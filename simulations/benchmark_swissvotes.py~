

# import geopandas as gpd

# import pyproj
# from shapely.ops import transform

# import json
# import plotly.express as px

import pandas as pd
import numpy as np

from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler

import networkx as nx
from pyvis.network import Network

from StructuredGraphLearning.utils import Operators
from StructuredGraphLearning.metrics import Metrics

from src.estimators import SGLkComponents


# f=r"/home/AHippert-Ferrer/Documents/graphfactormodel/data/swissBOUNDARIES3D_1_3_TLM_KANTONSGEBIET.shp"

# shapes = gpd.read_file(f)
# shapes.geometry = shapes.geometry.simplify(0.5)

# gdf = gpd.GeoDataFrame(columns=shapes.columns)

# lv95 = pyproj.CRS('EPSG:2056')
# wgs84 = pyproj.CRS('EPSG:4326')
# project = pyproj.Transformer.from_crs(lv95, wgs84, always_xy=True).transform

# for i, shape in shapes.iterrows():
#     if shape.geometry is not None:
#         shape.geometry = transform(project, shape.geometry)
#         shapes.iloc[i] = shape
     
# for i, shape in shapes.iterrows():
#     if shape.geometry is not None:
#         if shape.NAME in gdf.NAME.values:
#             available_geometry = gdf.loc[gdf.NAME == shape.NAME,'geometry'].geometry.values
#             gdf.loc[gdf.NAME == shape.NAME, 'geometry']=available_geometry.union(shape.geometry)
#         else:
#             gdf = gdf.append(shape)
# gdf = gdf.drop(columns=['KT_TEIL'])


# gdf = gdf.rename(columns={'EINWOHNERZ':'Inhabitants'})

df = pd.read_csv("../data/votations.csv", dtype={"INDEX": str})

df['mean'] = df.mean(axis=1)

X = df.values[:, 2:] # Remove Id and Canton name to only keep voting percentages
X = X.astype(np.float32)
X = X.T
#X = df.values[:, 2:].to_numpy(dtype=np.float32)
print(X.shape)

# Pre-processing
pre_processing = StandardScaler(with_mean=True, with_std=False)

SGL = Pipeline(steps=[
        ('Centering', pre_processing),
        ('Graph Estimation', SGLkComponents(
            None, maxiter=1000, record_objective=True, record_weights=True,
            beta = 1e4, k=3, verbosity=1)),
        #('Clustering', louvain(modularity='Newman', n_aggregations=n_clusters))
        ]
    )

list_names = ['SGL']
list_pipelines = [SGL]

# Doing estimation
for pipeline, name in zip(list_pipelines, list_names):
    print("----------------------------------------------------------")
    print("----------------------------------------------------------")
    print("Doing estimation with :", name)
    print(pipeline)
    pipeline.fit_transform(X)

    # Get adjacency matrix to get the graph and clustered labels to compute modularity
    adjacency = pipeline['Graph Estimation'].results_['adjacency']
    #labels = pipeline['Clustering'].labels_
    graph = nx.from_numpy_matrix(adjacency)
    print(adjacency)
    # graph = nx.relabel_nodes(graph, dict_names)

    laplacian_est = pipeline['Graph Estimation'].results_['laplacian']
    #metrics = Metrics(laplacian_true, laplacian_est)

    print('Graph statistics:')
    print('Nodes: ', graph.number_of_nodes(), 'Edges: ', graph.number_of_edges() )
    #print('Modularity: ', np.round(get_modularity(adjacency, labels), 2))
    #print('Rel error:', metrics.relative_error())
    #print('F1-score:', metrics.f1_score())
    print("----------------------------------------------------------")
    print('\n\n')

    nt = Network('100%', '100%')
    #nt.show_buttons()
    nt.set_options("""
    const options = { "nodes": {
    "borderWidth": 2,
    "borderWidthSelected": 1,
    "opacity": 1,
    "font": {
      "size": 15
    },
    "scaling": {
      "min": 17
    },
    "shadow": {
      "enabled": true
    },
    "size": 17
    },
    "edges": {
    "arrowStrikethrough": false,
    "color": {
      "inherit": true
    },
    "selfReferenceSize": null,
    "selfReference": {
      "angle": 0.7853981633974483
    },
    "shadow": {
      "enabled": true
    },
    "smooth": {
      "type": "continuous",
      "forceDirection": "none",
      "roundness": 1
    }
    },
    "physics": {
    "forceAtlas2Based": {
      "springLength": 100
    },
    "minVelocity": 0.75,
    "solver": "forceAtlas2Based"
  }
    }
    """)
        
    nt.from_nx(graph)

    # # Adding labels if possible
    # if hasattr(pipeline[-1], 'labels_'):
    #     for i_animal, i_cluster in enumerate(pipeline[-1].labels_):
    #         nt.nodes[i_animal]['color'] = cluster_colors[i_cluster]

    nt.show(f'swiss_votes.html')

#plt.show()


# plot_clusters = False
# if plot_clusters:
#     conditions = [(df.Immigre_09_02_2014<50),
#                   (df.Immigre_09_02_2014>=50) & (df.Immigre_09_02_2014<58.15),
#                   (df.Immigre_09_02_2014)>=58.15]

#     values = ["Against", "Support", "Strong support"]

#     df['cluster'] = np.select(conditions, values)

#     fig = px.choropleth_mapbox(df, geojson=gdf.geometry,
#                                locations='INDEX',
#                                color='cluster',
#                                hover_name = 'NAME',
#                                #color_continuous_scale='algae',
#                                mapbox_style="carto-positron",
#                                zoom=7,
#                                center = {"lat": 46.8, "lon": 8.5},
#                                opacity=0.5,
#                                )
#     fig.update_layout(margin={"r":0,"t":0,"l":0,"b":0})
#     fig.show()
